# config.py
#
# This module holds config related functions. This includes the EntryInfo data
# class too.

from __future__ import annotations

import dataclasses

from utils import to_form_url, to_normal_form_url

@dataclasses.dataclass
class EntryInfo:
    required: bool
    prompt: bool
    type: str
    key: str
    title: str
    value: str

    # See README's Config section for more info
    TYPES = {
        "words": ["w", "word", "text"],
        "choice": ["m", "mc", "multiple choice"],
        "checkboxes": ["c", "checkbox"],
        "date": ["d"],
        "time": ["t"],
        "extra": ["x", "xD", "extra data"],
    }

    @classmethod
    def from_string(cls, string):
        """
        Return info on a config file line.

        Parse a string of the format `[*] [!] type - key ; title = value`.
        Return a dataclass (simple object) with the config info.

        A string "*!type-key;title=value" would give `EntryInfo(required=True,
        prompt=True, type="type", key="key", title="title", value="value")`.

        Examples of config lines:
            w-1000;Question=Default
            ! time - 1001 ; Time = current
            *multiple choice - 1001 ; Class =
            checkbox-1002; Languages = Python, Java, C++
            *! extra-emailAddress; Email Address =
        """
        string = string.strip()

        # Check if the entry is required
        if not string:
            raise ValueError("Empty entry")
        required = (string[0] == "*")
        string = string.removeprefix("*").strip()

        # Check if the entry will use a prompt
        if not string:
            raise ValueError("Missing type")
        prompt = (string[0] == "!")
        string = string.removeprefix("!").strip()

        # Get the entry type
        type, split, string = map(str.strip, string.partition("-"))
        for name, aliases in cls.TYPES.items():
            if type == name:
                break
            elif type in aliases:
                type = name
                break
        else:
            raise ValueError(f"Type not valid: {type}")
        if not split:
            raise ValueError("Missing type-key split '-'")

        # Get the entry key
        key, split, string = map(str.strip, string.partition(";"))
        if not key:
            raise ValueError("Missing key")
        if not split:
            raise ValueError("Missing key-title split ';'")

        # Get the entry title / value
        title, split, value = map(str.strip, string.partition("="))
        if not title:
            title = key  # Title defaults to the key if absent.
        if not split:
            raise ValueError("Missing title-value split '='")

        return cls(required, prompt, type, key, title, value)

    def __str__(self):
        return (
            f"{'*'*self.required}{'!'*self.prompt}{self.type}"
            f"-{self.key};{self.title}={self.value}"
        )

@dataclasses.dataclass
class ConfigInfo:
    url: str
    entries: list[EntryInfo]
    title: Optional[str]
    description: Optional[str]

    @classmethod
    def from_file(cls, file):
        """
        Open config file and return the URL and entries.
        """
        if isinstance(file, str):
            with open(file) as file:
                return cls.from_file(file)

        url = to_form_url(file.readline())
        entries = []
        title = None
        description = []

        fileiter = map(str.strip, iter(file))
        for line in fileiter:

            # Special code to detect autogenerated title / description
            if line.startswith("#"):
                if title is not None:  # Already defined
                    continue
                if entries:  # Title / description are before entries
                    continue
                search = {"auto-generated", "info"}
                if not any(word in line.lower() for word in search):
                    continue
                try:
                    if (line := next(fileiter)).startswith("# "):
                        title = line.removeprefix("# ")
                        while (line := next(fileiter)).startswith("#   "):
                            description.append(line.removeprefix("#   "))
                except StopIteration:
                    break
                else:
                    pass  # Fall-through to other options

            # Normal processing
            if not line:
                continue
            entries.append(EntryInfo.from_string(line))

        # Make description an Optional[str]
        if not description:
            description = None
        else:
            description = "\n".join(description)

        return cls(url, entries, title, "\n".join(description))

    # Create entries from info
    # `info` needs "types", "titles", "keys", "required", and "options"
    @classmethod
    def from_info(cls, info):
        entries = []
        if info["takes_email"]:
            args = (True, True, "extra", "emailAddress", "Email address", "")
            entries.append(EntryInfo(*args))
        for type, title, key, required, options in zip(
            info["types"], info["titles"], info["keys"],
            info["required"], info["options"],
        ):
            if options:
                title = f"{title} ({', '.join(options)})"
            entries.append(EntryInfo(required, True, type, key, title, ""))
        return cls(
            info["form_url"], entries,
            info.get("form_title"), info.get("form_description")
        )

    # Iterator of config lines from info
    def to_config_lines(self):
        # First line should be a link that you can paste into a browser
        yield to_normal_form_url(self.url)

        # Note that the file was auto-generated
        yield "# Auto-generated using form.py"

        if self.title:
            yield f"# {self.title}"
        if self.description:
            for line in self.description.splitlines():
                yield f"#   {line}"

        for entry in self.entries:
            yield str(entry)

# - Tests

def test_entry_from_string():
    # TODO: Add tests for ValueError (maybe use pytest)
    a = EntryInfo(True, True, "words", "key", "title", "value")
    assert EntryInfo.from_string(" *!words-key;title=value ") == a
    assert EntryInfo.from_string(" * ! words - key ; title = value ") == a

    b = EntryInfo(False, False, "words", "key", "key", "")
    assert EntryInfo.from_string("words-key;=") == b
    assert EntryInfo.from_string("w-key;=") == b
    assert EntryInfo.from_string("word-key;=") == b
    assert EntryInfo.from_string("text-key;=") == b

def test_entry_str():
    entry = EntryInfo(True, True, "words", "key", "title", "value")
    assert EntryInfo.from_string(str(entry)) == entry

    line = "*!words-key;title=value"
    assert str(entry) == line
    assert str(EntryInfo.from_string(line)) == line
